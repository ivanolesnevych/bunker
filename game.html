<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Бункер — Гра</title>
<style>
  :root{
    --bg:#0b0820;
    --muted: rgba(243,232,255,0.65);
    --soft:#f3e8ff;
    --glass-border: rgba(255,255,255,0.06);
    --green: #2ecc71;
    --red: #ff4d4f;
    --accent-start: #ff6b00;
    --accent-end: #ff1f4a;
    --card-used: rgba(255,255,255,0.06);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    background: radial-gradient(circle at 10% 10%, #120021 0%, var(--bg) 35%, #05030a 100%);
    color:var(--soft);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    padding:28px;
  }
  .top { display:flex; align-items:center; justify-content:center; position:relative; margin-bottom:12px; }
  .title { font-size:32px; font-weight:700; color:var(--soft); text-shadow: 0 6px 18px rgba(255,95,95,0.07); }
  #endVotingBtn { position:absolute; right:0; top:0;
    background: linear-gradient(135deg,var(--accent-start),var(--accent-end));
    color:#fff; border:0; padding:10px 16px; border-radius:20px; cursor:pointer;
    box-shadow: 0 12px 36px rgba(255,50,50,0.12);
  }
  #endVotingBtn:disabled { opacity:0.45; cursor:not-allowed; transform:translateY(2px); }

  .disaster-card { margin:18px auto; max-width:1100px; border-radius:16px; padding:18px;
    background: linear-gradient(180deg, rgba(255,120,60,0.12), rgba(40,10,10,0.12));
    border: 1px solid rgba(255,80,50,0.14); box-shadow: 0 12px 40px rgba(255,80,50,0.06), inset 0 -2px 12px rgba(0,0,0,0.25);
    display:flex; gap:18px; align-items:flex-start; animation: pop .45s ease;
  }
  .disaster-left { flex: 0 0 340px; padding:12px; border-radius:12px; background: linear-gradient(135deg, rgba(255,60,60,0.12), rgba(255,140,40,0.06)); border: 1px solid rgba(255,100,60,0.12); }
  .disaster-right { flex: 1 1 auto; padding:12px; }
  .dis-title { font-size:22px; font-weight:800; margin-bottom:8px; color:#fff; text-shadow:0 6px 18px rgba(255,80,60,0.08); }
  .dis-desc { color: #ffe9e0; opacity:0.95; margin-bottom:12px; line-height:1.3; }
  .bunker-title { font-weight:800; margin-top:6px; color:#fff; }
  .bunker-list { display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
  .bunker-item { background: rgba(0,0,0,0.18); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.03); color:#fff; }
  .bunker-flag { font-weight:700; color:#fff; margin-bottom:6px; display:block; }
  .tiny { font-size:13px; color:#ffd9cf; }

  @keyframes pop { from { transform: translateY(8px); opacity:0 } to { transform: translateY(0); opacity:1 } }

  .top-area { display:flex; gap:20px; margin-top:20px; flex-wrap:wrap; align-items:flex-start; }
  .my-panel, .actions, .my-cards { background: rgba(255,255,255,0.02); border-radius:12px; padding:16px; border:1px solid var(--glass-border); }
  .my-panel { flex:1 1 420px; min-width:300px; }
  .actions { width:320px; min-width:260px; }
  .my-cards { width:260px; min-width:220px; margin-left:12px; }

  .section-title { color:var(--soft); font-weight:600; margin-bottom:12px; }

  .stat-row { display:flex; justify-content:space-between; align-items:center; padding:8px; border-radius:8px; transition: transform .12s, background .12s; }
  .stat-row:hover { transform: translateY(-2px); }
  .stat-key { color:var(--muted); font-size:14px; }
  .stat-val { font-weight:700; }

  .players-wrap { margin-top:26px; padding:18px; background: rgba(255,255,255,0.02); border-radius:14px; border:1px solid var(--glass-border); }
  .players-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:20px; margin-top:20px; }

  @media (min-width:1100px){
    .players-grid { grid-template-columns: repeat(3, 1fr);}
  }

  .player-card { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:12px; border:1px solid rgba(255,255,255,0.03); backdrop-filter: blur(6px); transition: transform .15s, box-shadow .15s, filter .18s, border-color .12s; position:relative; min-height:220px; }
  .player-card.kicked { filter: blur(4px) grayscale(.5); opacity:.45; pointer-events:none; }
  .player-name { text-align:center; font-weight:800; color:var(--soft); margin-bottom:10px; font-size:16px; }
  .stat-line { display:flex; justify-content:space-between; align-items:center; padding:6px 6px; margin:6px 0; border-radius:8px; }

  .badge { padding:6px 10px; border-radius:10px; font-weight:700; font-size:13px; min-width:96px; text-align:center; color:#fff; cursor:pointer; }
  .badge.hidden { background: linear-gradient(135deg,#ff6b6b,#ff4d4f); box-shadow:0 8px 18px rgba(255,77,79,0.12); }
  .badge.open { background: linear-gradient(135deg,#34d399,#10b981); box-shadow:0 8px 18px rgba(16,185,129,0.12); }
  .badge.own { background: linear-gradient(135deg,#ffd7a6,#ffb86b); color:#2c1300; box-shadow:0 8px 18px rgba(255,184,107,0.12); }

  .player-actions { display:flex; gap:8px; justify-content:center; margin-top:12px; }

  .btn-kick { background: linear-gradient(180deg,#ffd3d3,#ff9b9b); color:#330000; border-radius:12px; padding:8px 12px; border:none; cursor:pointer; font-weight:700; }
  .btn-kick:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(255,80,80,0.12); }

  .voted { outline: 3px solid rgba(255,100,60,0.45); box-shadow: 0 10px 30px rgba(255,100,60,0.12); }

  /* Cards list */
  .card { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); padding:10px; border-radius:10px; margin-bottom:10px; display:flex; flex-direction:column; gap:8px; border:1px solid rgba(255,255,255,0.03); }
  .card.used { opacity:0.38; background: var(--card-used); pointer-events:none; transform: none; }
  .card .name { font-weight:800; }
  .card .desc { color:var(--muted); font-size:13px; }
  .card .row { display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .use-btn { background: linear-gradient(135deg,#7b61ff,#ff6fb3); border:0; color:white; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:700; }

  /* Modal */
  .modal-backdrop { position:fixed; inset:0; background: rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:9999; }
  .modal { background: #0b0b12; border-radius:12px; padding:18px; width:420px; max-width:94%; border:1px solid rgba(255,255,255,0.04); box-shadow: 0 20px 60px rgba(0,0,0,0.7); }
  .modal h3 { margin:0 0 12px 0; color:var(--soft); }
  .modal .controls { display:flex; flex-direction:column; gap:8px; margin-top:10px; }
  .modal .controls select, .modal .controls button { padding:8px; border-radius:8px; border:0; font-weight:700; }
  .modal .confirm { background: linear-gradient(135deg,#34d399,#10b981); color:#032; }
  .modal .cancel { background: linear-gradient(135deg,#ffd3d3,#ff9b9b); color:#330; }

  /* Top banner for last card used */
  .banner { position:fixed; top:14px; left:50%; transform:translateX(-50%); background: linear-gradient(90deg,#ff8a6b,#ff3a8a); color:white; padding:12px 20px; border-radius:999px; box-shadow:0 10px 30px rgba(255,60,80,0.14); z-index:9998; opacity:0; pointer-events:none; transition: all .36s ease; }
  .banner.show { opacity:1; transform: translateX(-50%) translateY(0); pointer-events:auto; }
  .banner.hide { opacity:0; transform: translateX(-50%) translateY(-10px); }

  /* animation */
  .player-card, .my-panel { opacity:0; transform: translateY(8px); animation: fadeIn .36s ease forwards; }
  .player-card { animation-delay: .06s; }
  @keyframes fadeIn { to { opacity:1; transform: translateY(0);} }
</style>
</head>
<body>

  <div class="top">
    <div class="title">Бункер</div>
    <button id="endVotingBtn" disabled>Завершити голосування</button>
  </div>

  <div id="disasterCard" class="disaster-card" role="region" aria-label="Катастрофа">
    <div class="disaster-left">
      <div class="dis-title" id="disTitle">Катастрофа — ...</div>
      <div class="dis-desc" id="disShort">Опис...</div>
      <div class="tiny" id="disTagline"></div>
    </div>
    <div class="disaster-right">
      <div class="bunker-title">Опис бункера</div>
      <div style="margin-top:8px" id="bunkerSummary"></div>
      <div style="margin-top:12px;color:#ffd9cf;font-weight:700;">Примітка: у цей бункер проходять <span id="bunkerSlots">3</span> гравці</div>
    </div>
  </div>

  <div class="top-area">
    <div class="my-panel">
      <div class="section-title">Ваші характеристики</div>
      <div id="myStats"></div>
    </div>


    <div class="my-cards">
      <div class="section-title">Ваші карти</div>
      <div id="cardsList"></div>
    </div>
  </div>

  <div class="players-wrap">
    <div class="section-title" style="text-align:center;color:var(--soft);margin-bottom:6px;">Гравці</div>
    <div class="players-grid" id="playersGrid"></div>
  </div>

  <div id="banner" class="banner hide">Остання карта: ...</div>

  <!-- Modal scaffold -->
  <div id="modalRoot" style="display:none"></div>

<script type="module">
// --------------- Firebase init ---------------
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
import { getDatabase, ref, onValue, update, set, get, push } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBDJs9FCbc7nJsBDokGNu5WtssemhSdt6A",
  authDomain: "bunkergame-3e81c.firebaseapp.com",
  databaseURL: "https://bunkergame-3e81c-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "bunkergame-3e81c",
  storageBucket: "bunkergame-3e81c.firebasestorage.app",
  messagingSenderId: "769825223500",
  appId: "1:769825223500:web:189d1834abf3fa2634d5e9"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// --------------- Room / Player ---------------
const room = localStorage.getItem("room");
const player = localStorage.getItem("player");
if (!room || !player) {
  alert("Помилка: ви не в кімнаті. Поверніться в лобі.");
  throw new Error("no room/player");
}

// --------------- small data lists (shortened) ---------------
const professions = ["Стоматолог","Інженер","Повар","Пілот","Програміст","Фізик","Матемитак","Хірург","Психолог","Механік","Фармацефт","Блогер","Безробітній","Інструктор по виживанню","Стриптизер","Продавець","Кінолог","Архітектор","Хімік","Військовий","Президент","Актор","Наркобарон","Футболіст","Вчитель","Акушер","Співак","Швея","Фермер","Біолог","Таксіст","Слюсар","Маркетолог","Перекладач","ТікТокер","Начальник Тюрми","Кіберспортсмен","Вбивця","Крадій","Знахарь","Бізнесмен","Директор Школи","Психіатр"];

const hobbies = ["Ігри","Спортзал","Музика","Рибалка","Малювання","Танці","Ветеринар","Скалолаз","Стрільба з лука","Стрільба з вогнепальної зброї","Ремонт радіо","Вивчення різних мов","Пивоварство","Фермерство","Скотоводство","Нема хоббі","СтендАп","Прибирання","Бої без правил","Крадіжка","Вбивство","Знущатися над слабшим","Куріння"];

const healthList = ["Повністю здоровий","Рак Легенів","Рак Крові","Без 1 ноги","Без 2 ніг","Заікається","Сліпота 10%","Сліпота 50%","Сліпота 100%","Без 1 руки","Без 2 рук","Гастріт","Грижа","Аутизм","Шизофренія","Тремор 10%","Тремор 50%","Тремор 100%","Глухонімий","Карликовість","Гігантизм","Стікляна Людина","Ожиріння 10%","Ожиріння 50%","Оєиріння 100%","Сифіліс","ВІЧ","Плоскостопія","Скліроз","Гепатит Б","Гемофілія","Не тримання мочі/калу","Алергія на воду(пити може)","Алергія на пил","Алергія на Сонце","Алергія на Горіхи"];

const bagList = ["Ящик пива","Заряжений пістолет","Протез частини тіла","Мішок Бараболі","Наркотики","Аптечка","Ліки від Раку","Собака","Кіт","Папугай","Набор садовника","Радіоактивний Плутоній","Атомний Годинник","Букет Квітів","Набір Настольних Ігор","Інвалідна Каляска"," Чужа Дитина 5 місяців","Колекція Еротичних Журналів","Посібник по виживанню","Гітара","Складний Велосипед","Монітор","Радіо","Набір сємочок","Вудочка","Гантелі 10кг","Термометр","Окуляри","Лук зі Стрілами","1 Вакцина проти Зомбі","Мяч Футбольний","Набір Виживальщика","Снюс","Окуляри(+50%)","Консерв на 1 місяць","Хімікати","Папір і ручки","Ящик Інструментів","Набір Ножів"];

const factsList = ["Гей","Брав участь у Теракті","Вижив при Авіакатастрофі","Не довіряє незнайомцям","Був у кожній країні світу","Приймав Роди","Дивився 100 фільмів про Апокаліпсіс","Знайомий з Зеленським","Знає азбуку Морзе","Провів 3 дня в лісі без їди","Працював поваром","Торгував Наркотиками","ГомоФоб","Розводився 5 раз","Воював","МС по плаванню","Був в книзі рекордів Гіннеса","Знаю рецепт простих лікарст","Покорив Еверест","Виграв Мажор в КС","Опит в ескорті","Ненавидить дітей","Знає всі вірші Шевченка","Потомственна Відьма/Відьмак","ГрекоРимський Борець","Говорить тільки на Видуманій Мові","Не вміє плавати","Любить Обмазуватися Гамном","Має глисти","Боїться Стоматологів","Не знає таблички Множення","Не закінчив Школу","Виграв в казино","Поборов Рак","Не вміє читати","Зоофіл","Знаток Комах","Знаток рослин","Знаток Тварин","Не переносить різких запахів","Дуже смердючо пердить","Облизує стіни","Смішно шуткує","Колишній Футболіст","Бачив Привида","Дєвствєнік","Дитина Трампа","Знає рецепт КрабсБургера","Орієнтується по Зірках"];

const phobias = [
  "Арахнофобія (страх павуків)",
  "Клаустрофобія (страх замкнених просторів)",
  "Акрофобія (страх висоти)",
  "Аерофобія (страх польотів)",
  "Танатофобія (страх смерті)",
  "Соціофобія (страх людей)",
  "Агорафобія (страх відкритих просторів)",
  "Офідіофобія (страх змій)",
  "Гемофобія (страх крові)",
  "Ніктофобія (страх темряви)",
  "Мізофобія (страх бруду та бактерій)",
  "Трипофобія (страх отворів)",
  "Кінофобія (страх собак)",
  "Ентомофобія (страх комах)",
  "Гідрофобія (страх води)",
  "Астрафобія (страх грози)",
  "Коулрофобія (страх клоунів)",
  "Нозофобія (страх хвороб)",
  "Токофобія (страх пологів)",
  "Хромофобія (страх яскравих кольорів)",
  "Гемофобія (страх крові)",
  "Гомофобія (страх геїв)"
];

const genders = ["Чоловік","Жінка","Невизначено"];
const badHealth = ["Рак Легенів","Рак Крові","Без 1 ноги","Без 1 руки","Глухонімий","Гепатит Б","Гемофілія"];

// --------------- Disasters ---------------
const disasters = [
  { title:"Зомбі-апокаліпсис", description:"Масова інфекція. Хаос.", bunker:{ allowedPlayers:3, supplies:{ Їда:"Їжі 6м", Вода:"Води 1р", Зброя:"2 рушниці", Медицина:"Аптечка", Предмети:"Радіо" }, missing:["Опалення"], duration:"10 рік", needChildren:true } },
  { title:"Пандемія", description:"Аерозольний вірус. Ізоляція.", bunker:{ allowedPlayers:3, supplies:{ Їда:"Раціони 9м", Вода:"Фільтр", Зброя:"Ніж", Медицина:"PPE", Предмети:"Фільтр" }, missing:["Вакцина"], duration:"3 роки", needChildren:true } },
  { title:"Падіння астероїда", description:"Атмосфера забруднена.", bunker:{ allowedPlayers:3, supplies:{ Їда:"Консерви 3м", Вода:"Обмежено", Зброя:"Пара стволів", Медицина:"Травми", Предмети:"Інструменти" }, missing:["Ресурси"], duration:"3 місяці", needChildren:false } }
];

// --------------- stats helpers ---------------
const statOrder = ["age","profession","health","hobby","bag","fact1","fact2","gender","fertility","phobia"];
const statNames = { age:"Вік", profession:"Професія", health:"Здоров'я", hobby:"Хобі", bag:"Багаж", fact1:"Факт 1", fact2:"Факт 2", gender:"Стать", fertility:"Плодовитість", phobia:"Фобія" };

function genOneStats(){
  const age = Math.floor(Math.random()*50)+18;
  const gender = Math.random() < 0.5 ? "Чоловік" : "Жінка";
  const fertileChance = (age < 60) ? 0.3 : 0.6;
  const fertility = Math.random() < fertileChance ? "Плодовитий" : "Безплідний";
  const base = {
    age,
    profession: professions[Math.floor(Math.random()*professions.length)],
    health: healthList[Math.floor(Math.random()*healthList.length)],
    hobby: hobbies[Math.floor(Math.random()*hobbies.length)],
    bag: bagList[Math.floor(Math.random()*bagList.length)],
    fact1: factsList[Math.floor(Math.random()*factsList.length)],
    fact2: factsList[Math.floor(Math.random()*factsList.length)],
    gender,
    fertility,
    phobia: phobias[Math.floor(Math.random()*phobias.length)],
    kicked:false,
    myKickVote:null
  };
  statOrder.forEach(k => base[k + "Open"] = false);
  return base;
}

// --------------- Cards metadata (1..30) ---------------
const cardsMeta = [
  { id:1, name:"Повне Оздоровлення", desc:"Повністю здоров'я + плодовитість", target:"any" },
  { id:2, name:"Відкриття характеристики", desc:"Виберіть гравця який розкриє ще одну характеристику", target:"any_inform" },
  { id:3, name:"Змінити катастрофу", desc:"Змінює катастрофу на випадкову", target:"room" },
  { id:4, name:"Обмін характеристиками", desc:"Обміняйте одну характеристику з іншим гравцем", target:"exchange" },
  { id:5, name:"Поміняти всім Вік/Плодовитість", desc:"Вік і Плодовитість у всіх на рандомні", target:"all" },
  { id:6, name:"Поміняти всім Здоров'я", desc:"Здоров'я у всіх на рандомне", target:"all" },
  { id:7, name:"Поміняти всім Хоббі", desc:"Хоббі у всіх на рандомне", target:"all" },
  { id:8, name:"Поміняти всім Професію", desc:"Професію у всіх на рандомну", target:"all" },
  { id:9, name:"Поміняти всім Факти", desc:"Факт1 і Факт2 у всіх на рандомні", target:"all" },
  { id:10, name:"Поміняти всім Фобію", desc:"Фобію у всіх на рандомну", target:"all" },
  { id:12, name:"Погіршити здоров'я", desc:"Погіршує здоров'я обраного гравця", target:"any" },
  { id:13, name:"Зменшити місць у бункері", desc:"Зменшує допустиму кількість людей в бункері до 2", target:"room" },
  { id:14, name:"Забрати зброю/медицину/предмети", desc:"Збільшити кількість води та їди,але забрати зброю/медицину/предмети", target:"room" },
  { id:15, name:"+5 років і потрібність дітей", desc:"Збільшити час перебування +5 років і вимога народжувати", target:"room" },
  { id:16, name:"Військова база поруч", desc:"Ви відкриваєте шлях до військової бази", target:"inform" },
  { id:17, name:"Питна вода поруч", desc:"Ви відкриваєте шлях до джерело питної води", target:"inform" },
  { id:18, name:"Стара лікарня поруч", desc:"Ви відкриваєте шлях до старої лікарні", target:"inform" },
  { id:20, name:"Збільшити припаси", desc:"Збільшує всі припаси бункера", target:"room" },
  { id:21, name:"Зменшити час перебування -1р", desc:"Зменшити час перебування на 1 рік", target:"room" },
  { id:22, name:"Змінити собі Вік/Плодовитість", desc:"Змінити Вік та Плодовитість лише собі", target:"self" },
  { id:23, name:"Змінити собі Здоров'я", desc:"Змінити лише своє здоров'я", target:"self" },
  { id:24, name:"Змінити собі Професію", desc:"Змінити лише свою професію", target:"self" },
  { id:25, name:"Змінити собі Факти", desc:"Змінити лише свої Факт1 та Факт2", target:"self" },
  { id:26, name:"Змінити собі Хоббі", desc:"Змінити лише своє Хоббі", target:"self" },
  { id:27, name:"Змінити собі Фобію", desc:"Змінити лише свою Фобію", target:"self" },
  { id:28, name:"Пропуск ходу", desc:"Всі відкривають ще по 1 характеристиці", target:"inform_all_open1" },
  { id:29, name:"Забрати потребу народжувати", desc:"Прибирає вимогу народжувати дітей", target:"room" },
  { id:30, name:"Добавити потребу народжувати", desc:"Додає вимогу народжувати дітей", target:"room" }
];

// --------------- Utils ---------------
function randFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function uid(){ return Math.random().toString(36).substring(2,9); }
function nowISO(){ return new Date().toISOString(); }

// banner show
let bannerTimer = null;
function showBanner(text){
  const b = document.getElementById('banner');
  b.textContent = text;
  b.classList.remove('hide'); b.classList.add('show');
  if (bannerTimer) clearTimeout(bannerTimer);
  bannerTimer = setTimeout(()=>{ b.classList.remove('show'); b.classList.add('hide'); }, 4500);
}

// --------------- ensure my stats and cards ---------------
async function ensureMyStatsAndCards(){
  const snap = await get(ref(db, `rooms/${room}/players/${player}/stats`));
  if (!snap.exists() || !snap.val()){
    const s = genOneStats();
    await set(ref(db, `rooms/${room}/players/${player}/stats`), s);
  }
  const cSnap = await get(ref(db, `rooms/${room}/players/${player}/cards`));
  if (!cSnap.exists() || !cSnap.val()){
    // give 2 random cards (unique)
    const ids = [];
    while(ids.length < 2){
      const n = Math.floor(Math.random()*cardsMeta.length)+1;
      if (!ids.includes(n)) ids.push(n);
    }
    const cardObjs = ids.map(id => ({ id, used:false, uid: uid() }));
    await set(ref(db, `rooms/${room}/players/${player}/cards`), cardObjs);
  }
}

// --------------- Render disaster ---------------
function renderDisasterCard(d){
  const titleEl = document.getElementById("disTitle");
  const descEl = document.getElementById("disShort");
  const bunkerSummary = document.getElementById("bunkerSummary");
  const bunkerSlots = document.getElementById("bunkerSlots");

  titleEl.textContent = d.title;
  descEl.textContent = d.description;
  bunkerSlots.textContent = d.bunker.allowedPlayers;

  bunkerSummary.innerHTML = "";
  const supplies = d.bunker.supplies || {};
  const ul = document.createElement("div");
  ul.className = "bunker-list";
  const keys = ["Їда","Вода","Зброя","Медицина","Предмети"];
  keys.forEach(k => {
    const item = document.createElement("div");
    item.className = "bunker-item";
    const tag = document.createElement("div"); tag.className = "bunker-flag"; tag.textContent = k.toUpperCase();
    const val = document.createElement("div"); val.className = "tiny";
    val.textContent = supplies[k] || "Немає";
    item.appendChild(tag); item.appendChild(val); ul.appendChild(item);
  });
  const missing = document.createElement("div"); missing.style.marginTop="10px";
  missing.innerHTML = `<strong>Чого немає:</strong> ${(d.bunker.missing && d.bunker.missing.length) ? d.bunker.missing.join(", ") : "Нічого"}`;
  const duration = document.createElement("div"); duration.style.marginTop="6px";
  duration.innerHTML = `<strong>Час перебування:</strong> ${d.bunker.duration}`;
  const needChildren = document.createElement("div"); needChildren.style.marginTop="6px";
  needChildren.innerHTML = `<strong>Чи потрібно народжувати дітей:</strong> ${d.bunker.needChildren ? "ТАК" : "НІ"}`;

  bunkerSummary.appendChild(ul);
  bunkerSummary.appendChild(missing);
  bunkerSummary.appendChild(duration);
  bunkerSummary.appendChild(needChildren);
}

// --------------- Render panels ---------------
function renderMyPanel(stats){
  const root = document.getElementById("myStats"); root.innerHTML="";
  statOrder.forEach(k => {
    const row = document.createElement("div"); row.className="stat-row";
    const key = document.createElement("div"); key.className="stat-key"; key.textContent = statNames[k] + ":";
    const valWrap = document.createElement("div"); valWrap.className="stat-val";
    const badge = document.createElement("div"); badge.className = "badge own"; badge.style.display="inline-block"; badge.style.cursor="pointer";
    badge.textContent = stats[k];
    if (stats[k + "Open"]) { badge.classList.remove("own"); badge.classList.add("open"); const c=document.createElement("span"); c.className="check"; c.textContent=" ✔"; badge.appendChild(c); }
    badge.onclick = async () => {
      const updates = {}; updates[`rooms/${room}/players/${player}/stats/${k}Open`] = true;
      await update(ref(db), updates);
    };
    valWrap.appendChild(badge); row.appendChild(key); row.appendChild(valWrap); root.appendChild(row);
  });
}

// --------------- Render players ---------------
function renderPlayers(allPlayers){
  const grid = document.getElementById("playersGrid"); grid.innerHTML = "";

  // kick counts
  const kickCounts = {};
  Object.keys(allPlayers).forEach(n => {
    const s = allPlayers[n].stats || {};
    const t = s.myKickVote;
    if (t) kickCounts[t] = (kickCounts[t]||0)+1;
  });

  const names = Object.keys(allPlayers);
  const alive = names.filter(n => !(allPlayers[n].stats && allPlayers[n].stats.kicked));
  const allVoted = alive.every(n => (allPlayers[n].stats && allPlayers[n].stats.myKickVote));
  document.getElementById('endVotingBtn').disabled = !allVoted;

  names.forEach(name => {
    const playerObj = allPlayers[name];
    const s = playerObj.stats || {};
    const card = document.createElement("div"); card.className="player-card";
    if (s.kicked) card.classList.add("kicked");
    if ((kickCounts[name]||0) > 0) card.classList.add("voted");

    const nm = document.createElement("div"); nm.className="player-name"; nm.textContent = name; card.appendChild(nm);

    statOrder.forEach(k => {
      const line = document.createElement("div"); line.className="stat-line";
      const left = document.createElement("div"); left.style.color="var(--muted)"; left.textContent = statNames[k];
      const right = document.createElement("div");
      const opened = !!s[k + "Open"];
      const badge = document.createElement("div"); badge.className = "badge " + (opened ? "open" : "hidden"); badge.style.display="inline-block";
      badge.textContent = opened ? String(s[k]) : "Приховано";
      if (opened) { const check = document.createElement("span"); check.className="check"; check.textContent=" ✔"; badge.appendChild(check); }
      if (name === player && !s.kicked) {
        badge.className = "badge own";
        badge.onclick = async () => { const updates = {}; updates[`rooms/${room}/players/${player}/stats/${k}Open`] = true; await update(ref(db), updates); };
      }
      right.appendChild(badge); line.appendChild(left); line.appendChild(right); card.appendChild(line);
    });

    const myStats = allPlayers[player] && allPlayers[player].stats ? allPlayers[player].stats : {};
    if (name !== player && !s.kicked && !(myStats && myStats.kicked)) {
      const actions = document.createElement("div"); actions.className="player-actions";
      const kc = kickCounts[name] || 0;
      const btnKick = document.createElement("button"); btnKick.className="btn-kick"; btnKick.textContent = `Вигнати (${kc})`;
      btnKick.onclick = async () => { const updates = {}; updates[`rooms/${room}/players/${player}/stats/myKickVote`] = name; await update(ref(db), updates); };
      actions.appendChild(btnKick); card.appendChild(actions);
    }

    grid.appendChild(card);
  });
}

// --------------- Render my cards ---------------
function renderMyCards(cards){
  const root = document.getElementById("cardsList"); root.innerHTML="";
  cards.forEach(c => {
    const meta = cardsMeta.find(x=>x.id===c.id);
    const el = document.createElement("div"); el.className = "card" + (c.used ? " used" : "");
    const name = document.createElement("div"); name.className="name"; name.textContent = ` ${meta.name}`;
    const desc = document.createElement("div"); desc.className="desc"; desc.textContent = meta.desc;
    const row = document.createElement("div"); row.className="row";
    const uidSpan = document.createElement("div"); uidSpan.style.fontSize="12px"; uidSpan.style.opacity=0.6; uidSpan.textContent = c.used ? "Використана" : "Готова";
    const btn = document.createElement("button"); btn.className="use-btn"; btn.textContent = "Використати";
    btn.disabled = !!c.used;
    btn.onclick = () => onUseCard(c);
    row.appendChild(uidSpan); row.appendChild(btn);
    el.appendChild(name); el.appendChild(desc); el.appendChild(row);
    root.appendChild(el);
  });
}

// --------------- Modal helpers ---------------
function showModal({ title, inputs = [], confirmText = "Підтвердити", cancelText = "Скасувати" }){
  // inputs: {type:"select", id, label, options:[{value,label}], placeholder}
  const root = document.getElementById("modalRoot");
  root.innerHTML = "";
  root.style.display = "flex";
  const backdrop = document.createElement("div"); backdrop.className="modal-backdrop";
  const modal = document.createElement("div"); modal.className="modal";
  const h = document.createElement("h3"); h.textContent = title; modal.appendChild(h);
  const ctrl = document.createElement("div"); ctrl.className="controls";
  const refs = {};
  inputs.forEach(inp => {
    if (inp.type === "select") {
      const sel = document.createElement("select"); sel.id = inp.id;
      const ph = document.createElement("option"); ph.value=""; ph.textContent = inp.placeholder || "—"; sel.appendChild(ph);
      inp.options.forEach(o => { const opt=document.createElement("option"); opt.value=o.value; opt.textContent=o.label; sel.appendChild(opt); });
      ctrl.appendChild(sel); refs[inp.id]=sel;
    } else if (inp.type === "text") {
      const t = document.createElement("input"); t.type="text"; t.id=inp.id; t.placeholder = inp.placeholder || ""; ctrl.appendChild(t); refs[inp.id]=t;
    }
  });
  const btnRow = document.createElement("div"); btnRow.style.display="flex"; btnRow.style.gap="8px"; btnRow.style.marginTop="12px";
  const btnConfirm = document.createElement("button"); btnConfirm.className="confirm"; btnConfirm.textContent=confirmText;
  const btnCancel = document.createElement("button"); btnCancel.className="cancel"; btnCancel.textContent=cancelText;
  btnRow.appendChild(btnCancel); btnRow.appendChild(btnConfirm);
  modal.appendChild(ctrl); modal.appendChild(btnRow); backdrop.appendChild(modal); root.appendChild(backdrop);

  return new Promise((resolve, reject) => {
    btnCancel.onclick = () => { root.style.display="none"; root.innerHTML=""; resolve(null); };
    btnConfirm.onclick = () => {
      const out = {};
      Object.keys(refs).forEach(k => out[k] = refs[k].value);
      root.style.display="none"; root.innerHTML=""; resolve(out);
    };
  });
}

// --------------- Card logic helpers ---------------
async function broadcastCardUse(cardMeta, payloadText){
  const info = { by: player, cardId: cardMeta.id, cardName: cardMeta.name, text: payloadText || "", ts: nowISO() };
  await update(ref(db, `rooms/${room}`), { lastCardUsed: info });
  showBanner(`${player} використав карту: ${cardMeta.name} ${payloadText ? "— "+payloadText : ""}`);
}

// apply update helper: accepts many updates object
async function applyUpdates(updates){
  await update(ref(db), updates);
}

// --------------- Implement card effects ---------------
async function executeCard(cardObj, cardIndex){
  const meta = cardsMeta.find(c=>c.id===cardObj.id);
  if (!meta) return alert("Невідома карта");
  // each card type handled here; many ask user via modal
  switch(meta.id){
    case 1: { // Повне оздоровлення — ціль будь-хто
      const playersSnap = await get(ref(db, `rooms/${room}/players`)); const players = playersSnap.val()||{};
      const options = Object.keys(players).map(n=>({ value:n, label:n }));
      const res = await showModal({ title:`${meta.name} — оберіть гравця`, inputs:[{type:"select", id:"target", options, placeholder:"Оберіть гравця"}], confirmText:"Підтвердити" });
      if (!res || !res.target) return;
      const updates = {};
      updates[`rooms/${room}/players/${res.target}/stats/health`] = "Повністю здоровий";
      updates[`rooms/${room}/players/${res.target}/stats/fertility`] = "Плодовитий";
      // mark card used
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `→ ${res.target}`);
      break;
    }
    case 2: { // Відкриття характеристики іншого — інформативна: показати використання (ціль в голосовому)
      const playersSnap = await get(ref(db, `rooms/${room}/players`)); const players = playersSnap.val()||{};
      const options = Object.keys(players).filter(n=>n!==player).map(n=>({value:n,label:n}));
      const res = await showModal({ title:`${meta.name} — оберіть на кого (тільки інформативно)`, inputs:[{type:"select", id:"target", options, placeholder:"Оберіть гравця"}], confirmText:"Підтвердити" });
      if (!res) return;
      const updates = {}; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `→ ${res.target || "хтось"}`);
      break;
    }
    case 3: { // Змінити катастрофу — рандом
      const newD = randFrom(disasters);
      const updates = {}; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `→ ${newD.title}`);
      break;
    }
    case 4: { // Обмін характеристиками: обираєш гравця і характеристику
      const playersSnap = await get(ref(db, `rooms/${room}/players`)); const players = playersSnap.val()||{};
      const options = Object.keys(players).filter(n=>n!==player).map(n=>({value:n,label:n}));
      const statOptions = statOrder.map(s=>({value:s,label:statNames[s]}));
      const res = await showModal({ title:`${meta.name} — виберіть гравця та характеристику`, inputs:[{type:"select", id:"target", options, placeholder:"Оберіть гравця"},{type:"select", id:"stat", options:statOptions, placeholder:"Оберіть характеристику"}], confirmText:"Побміняти" });
      if (!res || !res.target || !res.stat) return;
      const meSnap = await get(ref(db, `rooms/${room}/players/${player}/stats`)); const me=meSnap.val();
      const otherSnap = await get(ref(db, `rooms/${room}/players/${res.target}/stats`)); const other=otherSnap.val();
      if (!me || !other) return alert("Статуси відсутні");
      const updates = {};
      updates[`rooms/${room}/players/${player}/stats/${res.stat}`] = other[res.stat];
      updates[`rooms/${room}/players/${res.target}/stats/${res.stat}`] = me[res.stat];
      // keep .Open flags as they were (do not auto-open)
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `↔ ${res.target} (${statNames[res.stat]})`);
      break;
    }
    case 5: case 6: case 7: case 8: case 9: case 10: case 19: {
      // group "change everyone" actions
      const allPlayersSnap = await get(ref(db, `rooms/${room}/players`)); const players = allPlayersSnap.val()||{};
      const updates = {};
      Object.keys(players).forEach(n => {
        const stats = players[n].stats || {};
        if (meta.id === 5){ // age + fertility
          const newAge = Math.floor(Math.random()*50)+18;
          const newF = Math.random() < 0.5 ? "Плодовитий" : "Безплідний";
          updates[`rooms/${room}/players/${n}/stats/age`] = newAge;
          updates[`rooms/${room}/players/${n}/stats/fertility`] = newF;
        } else if (meta.id === 6){
          updates[`rooms/${room}/players/${n}/stats/health`] = randFrom(healthList);
        } else if (meta.id === 7){
          updates[`rooms/${room}/players/${n}/stats/hobby`] = randFrom(hobbies);
        } else if (meta.id === 8){
          updates[`rooms/${room}/players/${n}/stats/profession`] = randFrom(professions);
        } else if (meta.id === 9){
          updates[`rooms/${room}/players/${n}/stats/fact1`] = randFrom(factsList);
          updates[`rooms/${room}/players/${n}/stats/fact2`] = randFrom(factsList);
        } else if (meta.id === 10){
          updates[`rooms/${room}/players/${n}/stats/phobia`] = randFrom(phobias);
        } else if (meta.id === 19){
          updates[`rooms/${room}/players/${n}/stats/gender`] = randFrom(genders);
        }
      });
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `(всі гравці)`);
      break;
    }
    case 11: { // +1 голос на кік (adds a special field extraKickCounts maybe)
      const playersSnap = await get(ref(db, `rooms/${room}/players`)); const players = playersSnap.val()||{};
      const options = Object.keys(players).map(n=>({value:n,label:n}));
      const res = await showModal({ title:`${meta.name} — кому додати +1 голос`, inputs:[{type:"select", id:"target", options, placeholder:"Оберіть гравця"}], confirmText:"Додати" });
      if (!res || !res.target) return;
      // implement as room.extraKickCounts[target] +=1
      const extraSnap = await get(ref(db, `rooms/${room}/extraKickCounts/${res.target}`));
      const current = extraSnap.exists() ? (extraSnap.val()||0) : 0;
      const updates = {};
      updates[`rooms/${room}/extraKickCounts/${res.target}`] = current + 1;
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `→ ${res.target}`);
      break;
    }
    case 12: { // Погіршити здоров'я
      const playersSnap = await get(ref(db, `rooms/${room}/players`)); const players = playersSnap.val()||{};
      const options = Object.keys(players).map(n=>({value:n,label:n}));
      const res = await showModal({ title:`${meta.name} — виберіть гравця`, inputs:[{type:"select", id:"target", options, placeholder:"Оберіть гравця"}], confirmText:"Погіршити" });
      if (!res || !res.target) return;
      const bad = randFrom(badHealth);
      const updates = {};
      updates[`rooms/${room}/players/${res.target}/stats/health`] = bad;
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `→ ${res.target} (${bad})`);
      break;
    }
    case 13: { // зменшити allowedPlayers до 2
      const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters);
      d.bunker.allowedPlayers = 2;
      const updates = {}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(бункер -> 2 місця)`); break;
    }
    case 14: { // забрати зброю/медицину/предмети але додати їди/води
      const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters);
      d.bunker.supplies["Зброя"] = "Мало / відсутнє";
      d.bunker.supplies["Медицина"] = "Мало / відсутнє";
      d.bunker.supplies["Предмети"] = "Мало / відсутнє";
      d.bunker.supplies["Їда"] = (d.bunker.supplies["Їда"] || "") + " (+запаси)";
      d.bunker.supplies["Вода"] = (d.bunker.supplies["Вода"] || "") + " (+запаси)";
      const updates = {}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(запаси змінені)`); break;
    }
    case 15: { // +5 років duration and needChildren true
      const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters);
      // naive parse duration number if exists, else append +5
      let dur = d.bunker.duration || "";
      const m = dur.match(/(\d+)/);
      if (m){ const v = parseInt(m[1],10)+5; d.bunker.duration = `${v} ${dur.replace(m[1],"").trim()}`; } else { d.bunker.duration = (d.bunker.duration||"") + " +5 років"; }
      d.bunker.needChildren = true;
      const updates = {}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(бункер оновлено)`); break;
    }
    case 16: case 17: case 18: { // informative
      const updates = {}; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates);
      await broadcastCardUse(meta, `(інформативно)`);
      break;
    }
    case 20: { // збільшити припаси
      const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters);
      Object.keys(d.bunker.supplies || {}).forEach(k => { d.bunker.supplies[k] = (d.bunker.supplies[k]||"") + " (+)"; });
      const updates = {}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(запаси збільшено)`); break;
    }
    case 21: { // зменшити час -1 рік (спробуємо знайти число)
      const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters);
      let dur = d.bunker.duration || "";
      const m = dur.match(/(\d+)/);
      if (m){ const v = Math.max(0, parseInt(m[1],10)-1); d.bunker.duration = `${v} ${dur.replace(m[1],"").trim()}`; }
      else { d.bunker.duration = (d.bunker.duration||"") + " (-1 рік)"; }
      const updates = {}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(час зменшено)`); break;
    }
    case 22: case 23: case 24: case 25: case 26: case 27: {
      // change only self stat(s)
      const updates = {};
      if (meta.id === 22){ updates[`rooms/${room}/players/${player}/stats/age`] = Math.floor(Math.random()*50)+18; updates[`rooms/${room}/players/${player}/stats/fertility`] = Math.random()<0.5?"Плодовитий":"Безплідний"; }
      if (meta.id === 23){ updates[`rooms/${room}/players/${player}/stats/health`] = randFrom(healthList); }
      if (meta.id === 24){ updates[`rooms/${room}/players/${player}/stats/profession`] = randFrom(professions); }
      if (meta.id === 25){ updates[`rooms/${room}/players/${player}/stats/fact1`] = randFrom(factsList); updates[`rooms/${room}/players/${player}/stats/fact2`] = randFrom(factsList); }
      if (meta.id === 26){ updates[`rooms/${room}/players/${player}/stats/hobby`] = randFrom(hobbies); }
      if (meta.id === 27){ updates[`rooms/${room}/players/${player}/stats/phobia`] = randFrom(phobias); }
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(особисто)`); break;
    }
    case 28: { // пропуск ходу — інформативна: всі відкривають по 1 характеристиці
      const allSnap = await get(ref(db, `rooms/${room}/players`)); const players = allSnap.val()||{};
      const updates = {};
      Object.keys(players).forEach(n => {
        const stats = players[n].stats || {};
        // open first closed stat
        for (const s of statOrder){
          if (!stats[s + "Open"]){
            updates[`rooms/${room}/players/${n}/stats/${s}Open`] = true;
            break;
          }
        }
      });
      updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true;

      await applyUpdates(updates); await broadcastCardUse(meta, `(усі відкривають по 1)`); break;
    }
    case 29: { const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters); d.bunker.needChildren = false; const updates={}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true; await applyUpdates(updates); await broadcastCardUse(meta, `(потреба знята)`); break; }
    case 30: { const dSnap = await get(ref(db, `rooms/${room}/disasterObj`)); const d = dSnap.val() || randFrom(disasters); d.bunker.needChildren = true; const updates={}; updates[`rooms/${room}/disasterObj`] = d; updates[`rooms/${room}/players/${player}/cards/${cardIndex}/used`] = true; await applyUpdates(updates); await broadcastCardUse(meta, `(потреба додана)`); break; }
    default: { alert("Карта ще не реалізована"); break; }
  }
}

// helper: find index of cardObj in current player's cards array by uid
function cardObjIndex(cardObj){
  // this function will be called in context where we already have current copy of player's cards in cache
  // but to be safe we will fetch latest and find index
  // NOTE: we return path index (string) to use in updates object
  // Because Firebase array-like stored as actual array, we should use numeric index
  // We will fetch live synchronously via get (but it's async). To make life simpler: we will return placeholder and adjust callers to call getCardsIndex first.
  // Instead to avoid async inside many places, we built wrapper getCardsIndexAsync and callers used it above where needed.
  // Here we simply return a string used earlier in code by callers that awaited getCardsIndexAsync; but to support older calls, we implement safe fallback: - find using cachedCards variable.
  for (let i=0;i<cachedCards.length;i++){ if (cachedCards[i].uid === cardObj.uid) return i; }
  return 0;
}

// We'll keep cached cards for this player (refreshed on updates)
let cachedCards = [];

// wrapper to get index async
async function getCardsIndexAsync(cardObj){
  const snap = await get(ref(db, `rooms/${room}/players/${player}/cards`));
  const arr = snap.val() || [];
  for (let i=0;i<arr.length;i++) if (arr[i].uid === cardObj.uid) return i;
  return -1;
}

// --------------- onUseCard flow (confirmation, modal, execute) ---------------
async function onUseCard(cardObj){
  if (cardObj.used) return;

  const meta = cardsMeta.find(c=>c.id===cardObj.id);
  if (!meta) return alert("Невідома карта");

  const ok = await showModal({
    title:`Використати карту: ${meta.name}?`,
    inputs:[],
    confirmText:"Так",
    cancelText:"Ні"
  });
  if (!ok) return;

  // get fresh index from Firebase
  const snap = await get(ref(db, `rooms/${room}/players/${player}/cards`));
  const arr = snap.val() || [];
  const idx = arr.findIndex(c => c.uid === cardObj.uid);
  if (idx < 0) return alert("Карту не знайдено. Перезавантажте сторінку.");

  // now call executeCard with explicit index
  await executeCard(cardObj, idx);
}

// --------------- Listening to room and players ---------------
async function startSync(){
  await ensureMyStatsAndCards();

  // ensure disasterObj exists
  const dSnap = await get(ref(db, `rooms/${room}/disasterObj`));
  if (!dSnap.exists() || !dSnap.val()){
    const d = randFrom(disasters);
    await update(ref(db, `rooms/${room}`), { disasterObj: d });
  }

  onValue(ref(db, `rooms/${room}`), async (snap) => {
    const val = snap.val() || {};
    if (val.disasterObj) renderDisasterCard(val.disasterObj);
    const players = val.players || {};
    if (players[player] && players[player].stats) renderMyPanel(players[player].stats);
    renderPlayers(players);

    // render my cards from DB (fresh)
    const myCards = (players[player] && players[player].cards) ? players[player].cards : [];
    cachedCards = myCards;
    renderMyCards(myCards);

    // show lastCardUsed banner (if exists)
    if (val.lastCardUsed){
      const info = val.lastCardUsed;
      showBanner(`${info.by} використав карту: ${info.cardName} ${info.text ? "— "+info.text : ""}`);
    }
  });
}

// --------------- End voting (unchanged) ---------------
document.getElementById("endVotingBtn").addEventListener("click", async () => {
  const snap = await get(ref(db, `rooms/${room}/players`));
  const all = snap.val() || {};
  const counts = {};
  Object.keys(all).forEach(n => {
    const t = all[n].stats && all[n].stats.myKickVote;
    if (t) counts[t] = (counts[t]||0)+1;
  });
  let max = 0; let tops = [];
  Object.keys(counts).forEach(t => {
    if (counts[t] > max) { max = counts[t]; tops = [t]; } else if (counts[t] === max) tops.push(t);
  });
  if (tops.length === 1 && max > 0) {
    const toKick = tops[0];
    await update(ref(db, `rooms/${room}/players/${toKick}/stats`), { kicked: true });
  }
  const updates = {};
  Object.keys(all).forEach(n => updates[`rooms/${room}/players/${n}/stats/myKickVote`] = null);
  await update(ref(db), updates);
});

// --------------- Start ---------------
startSync();

</script>
</body>
</html>
